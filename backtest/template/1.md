下面给你一套可以直接放进项目里的 v2 核心代码，全部是新增文件，不会动你现有 v1 逻辑。整体分 4 个模块：


factors/core_factors_v2.py：残差动量 + mom_short/mom_long/vol60 + 排名


factors/market_vol_regime.py：市场波动 z-score + 简单 regime


factors/residual_momentum.py：对行业/风格指数做回归，得到残差收益


backtest/execution_v2.py：多标的 T+1、先卖后买的执行器（简化，不做整手）


backtest/engine_v2.py：把上面全部串起来，形成“TopN + 波动自适应 + 软闸门”的回测引擎


你可以先把这些文件直接建立好，后面再根据需要往里加细节（组限额、宏观微调等）。

1. 残差动量 + 基础因子（factors/core_factors_v2.py）
# factors/core_factors_v2.py
# -*- coding: utf-8 -*-
"""
v2 基础因子：
- 残差收益（对行业/风格指数回归后得到的 resid_ret）
- mom_short / mom_long（残差动量）
- vol60（残差波动）
- 横截面排名 0-1
"""

from __future__ import annotations
from dataclasses import dataclass
from typing import Dict, Tuple

import numpy as np
import pandas as pd

from .residual_momentum import compute_residual_return_series


@dataclass
class FactorWindows:
    mom_short: int = 10
    mom_long: int = 60
    vol: int = 60


def _rolling_sum(s: pd.Series, window: int) -> pd.Series:
    return s.rolling(window, min_periods=window).sum()


def _rolling_std(s: pd.Series, window: int) -> pd.Series:
    return s.rolling(window, min_periods=window).std()


def compute_stock_factor_panel(
    stock_universe: Dict[str, pd.DataFrame],
    index_df: pd.DataFrame,
    windows: FactorWindows | None = None,
) -> Dict[str, pd.DataFrame]:
    """
    对股票池中每只股票，计算：
      - resid_ret: 残差收益
      - mom_short, mom_long, vol60: 基于残差收益的动量/波动
    返回：{code: df}，index 为日期
    """
    if windows is None:
        windows = FactorWindows()

    # 统一处理指数收益
    idx = index_df.sort_index()
    idx["ret_idx"] = idx["close"].pct_change().fillna(0.0)

    result: Dict[str, pd.DataFrame] = {}

    for code, df in stock_universe.items():
        s = df.sort_index().copy()
        s["ret"] = s["close"].pct_change().fillna(0.0)

        resid = compute_residual_return_series(
            stock_ret=s["ret"], index_ret=idx["ret_idx"]
        )

        fac = pd.DataFrame(index=s.index)
        fac["resid_ret"] = resid
        fac["mom_short"] = _rolling_sum(resid, windows.mom_short)
        fac["mom_long"] = _rolling_sum(resid, windows.mom_long)
        fac["vol60"] = _rolling_std(resid, windows.vol)

        result[code] = fac

    return result


def cross_section_rank_0_1(
    factor_panel: Dict[str, pd.DataFrame],
    col: str,
) -> Dict[str, pd.Series]:
    """
    对某一列因子做横截面 0-1 排名。
    返回：{code: rank_series}
    """
    # 先收集所有日期
    all_dates = sorted(
        set().union(*[df.index for df in factor_panel.values()])
    )
    ranks_by_code: Dict[str, pd.Series] = {code: pd.Series(dtype=float)
                                           for code in factor_panel.keys()}

    for dt in all_dates:
        vals = {}
        for code, df in factor_panel.items():
            if dt in df.index:
                v = df.at[dt, col]
                if np.isfinite(v):
                    vals[code] = float(v)

        if len(vals) <= 1:
            continue

        # 排名 0-1
        ser = pd.Series(vals)
        rank = ser.rank(method="average")
        rank_01 = (rank - 1) / (len(rank) - 1)

        for code, r in rank_01.items():
            s = ranks_by_code[code]
            ranks_by_code[code] = s.reindex(s.index.union([dt]))
            ranks_by_code[code].at[dt] = r

    # 对齐 index 顺序
    for code, s in ranks_by_code.items():
        ranks_by_code[code] = s.sort_index()

    return ranks_by_code


def build_composite_score_panel(
    factor_panel: Dict[str, pd.DataFrame],
    alpha_mom_short: float = 0.6,
    alpha_mom_long: float = 0.3,
    alpha_vol: float = 0.1,
    gamma_resid_mom: float = 0.2,
) -> Dict[str, pd.DataFrame]:
    """
    基于残差动量的组合打分：
      score_base = α1*mom_short_r + α2*mom_long_r + α3*(-vol_r)
      score = score_base + γ*resid_mom_rank（这里 resid_mom_rank 用 mom_short_r 再加权视作近似）
    返回：{code: df}，df 至少包含：
      - score_base
      - score
      - mom_short_r / mom_long_r / vol_r
    """
    # 计算各项横截面排名
    mom_short_r = cross_section_rank_0_1(factor_panel, "mom_short")
    mom_long_r = cross_section_rank_0_1(factor_panel, "mom_long")
    vol_r = cross_section_rank_0_1(factor_panel, "vol60")

    result: Dict[str, pd.DataFrame] = {}

    for code, df in factor_panel.items():
        fac = pd.DataFrame(index=df.index)
        fac["mom_short_r"] = mom_short_r.get(code, pd.Series(dtype=float))
        fac["mom_long_r"] = mom_long_r.get(code, pd.Series(dtype=float))
        fac["vol_r"] = vol_r.get(code, pd.Series(dtype=float))

        # 这里 resid_mom_rank 简化为 mom_short_r，再往后你可以改成专门的残差动量排名
        fac["resid_mom_rank"] = fac["mom_short_r"]

        fac["score_base"] = (
            alpha_mom_short * fac["mom_short_r"]
            + alpha_mom_long * fac["mom_long_r"]
            - alpha_vol * fac["vol_r"]
        )
        fac["score"] = fac["score_base"] + gamma_resid_mom * fac["resid_mom_rank"]

        result[code] = fac

    return result


2. 市场波动 regime（factors/market_vol_regime.py）
# factors/market_vol_regime.py
# -*- coding: utf-8 -*-
"""
市场波动 regime：
- 计算指数 60 日年化波动
- 得到 z-score
- 简单给出 risk_on / neutral / risk_off 三档
"""

from __future__ import annotations
from dataclasses import dataclass
import numpy as np
import pandas as pd


@dataclass
class VolRegimeParams:
    vol_window: int = 60
    ann_factor: int = 252


def compute_index_vol_z(
    index_df: pd.DataFrame,
    params: VolRegimeParams | None = None,
) -> pd.DataFrame:
    """
    输入：指数 df（至少包含 close）
    输出：df_vol，包含：
      - ret_idx
      - vol60
      - vol_z
      - regime: risk_on / neutral / risk_off
    """
    if params is None:
        params = VolRegimeParams()

    df = index_df.sort_index().copy()
    df["ret_idx"] = df["close"].pct_change().fillna(0.0)

    vol = df["ret_idx"].rolling(params.vol_window, min_periods=params.vol_window).std()
    vol_ann = vol * np.sqrt(params.ann_factor)

    mu = vol_ann.expanding().mean()
    sigma = vol_ann.expanding().std().replace(0, np.nan)
    z = (vol_ann - mu) / (sigma + 1e-9)

    df["vol60"] = vol_ann
    df["vol_z"] = z

    # regime 划分（你后面可以自己微调阈值）
    cond_risk_off = df["vol_z"] >= 1.0
    cond_risk_on = df["vol_z"] <= -0.5
    regime = pd.Series("neutral", index=df.index)
    regime[cond_risk_on] = "risk_on"
    regime[cond_risk_off] = "risk_off"
    df["regime"] = regime

    return df


3. 残差收益序列（factors/residual_momentum.py）
# factors/residual_momentum.py
# -*- coding: utf-8 -*-
"""
对单只股票的收益率序列与行业/风格指数收益做一元回归，
得到残差收益序列 resid_ret。
"""

from __future__ import annotations
import numpy as np
import pandas as pd


def compute_residual_return_series(
    stock_ret: pd.Series,
    index_ret: pd.Series,
    min_obs: int = 60,
) -> pd.Series:
    """
    输入：
      stock_ret: 股票日收益（Series，index 为日期）
      index_ret: 对应指数日收益（Series，index 为日期）
    输出：
      resid_ret: 残差收益，index 对齐 stock_ret
    实现方式：用滚动窗口计算 beta，这里先用“全样本一次回归”的近似，
    后面你可以改成真正的滚动回归。
    """
    s = stock_ret.align(index_ret, join="inner")[0]
    i = index_ret.align(stock_ret, join="inner")[0]
    df = pd.DataFrame({"s": s, "i": i}).dropna()

    if len(df) < min_obs:
        # 样本太少就直接视为 resid = s
        resid = stock_ret.copy()
        resid.loc[:] = stock_ret
        return resid

    x = df["i"].values
    y = df["s"].values

    # 最简 OLS：y = a + b x
    x_mean = x.mean()
    y_mean = y.mean()
    cov = ((x - x_mean) * (y - y_mean)).sum()
    var = ((x - x_mean) ** 2).sum()
    if var == 0:
        beta = 0.0
    else:
        beta = cov / var

    fitted = beta * df["i"]
    resid_local = df["s"] - fitted

    resid = stock_ret.copy()
    resid.loc[resid_local.index] = resid_local
    return resid


4. 多标的执行器 v2（backtest/execution_v2.py）
# backtest/execution_v2.py
# -*- coding: utf-8 -*-
"""
多标的 T+1 执行引擎（简化版）：
- 先卖后买
- 每日根据 target_weight_t，在 t+1 日开盘成交
- 不做整手约束（后续你可以加 floor( /100)*100）
"""

from __future__ import annotations
from dataclasses import dataclass
from typing import Dict
import pandas as pd
import numpy as np


@dataclass
class ExecutionConfig:
    initial_cash: float = 1_000_000.0
    fee_rate: float = 0.0005
    slippage: float = 0.0005


def run_execution_t1_equal_weight(
    price_panel: Dict[str, pd.DataFrame],
    target_weights: pd.DataFrame,
    cfg: ExecutionConfig | None = None,
) -> pd.DataFrame:
    """
    price_panel: {code: df}，df 至少包含 ["open", "close"]，index 为日期
    target_weights: DataFrame，index 为日期，列为 code，值为当日目标权重（0~1）
                   约定：在 t 日给出的权重，在 t+1 日开盘成交。
    返回：资金曲线 DataFrame（index 为日期）：
      - equity, cash, mv, ret
    """
    if cfg is None:
        cfg = ExecutionConfig()

    # 对齐所有日期
    all_dates = sorted(target_weights.index)
    codes = list(price_panel.keys())

    # 当前持仓 股数
    shares = {code: 0.0 for code in codes}
    cash = cfg.initial_cash

    records = []

    for i in range(len(all_dates) - 1):
        t = all_dates[i]
        t_next = all_dates[i + 1]

        w_t = target_weights.loc[t].fillna(0.0)

        # 1) 先在 t 计算组合市值（用 close）
        mv = 0.0
        for code in codes:
            dfp = price_panel[code]
            if t not in dfp.index:
                continue
            close_t = dfp.at[t, "close"]
            mv += shares[code] * close_t

        equity_t = cash + mv

        # 2) 在 t+1 开盘执行 rebalance：先卖后买
        # 2.1 计算目标市值
        target_mv = w_t * equity_t

        # 实际在 t+1 执行
        cash_t1 = cash
        for code in codes:
            dfp = price_panel[code]
            if t_next not in dfp.index:
                continue
            open_next = dfp.at[t_next, "open"]

            cur_shares = shares[code]
            cur_mv_t = cur_shares * open_next  # 近似用开盘价估算当前市值
            tgt_mv_t = target_mv.get(code, 0.0)

            diff_mv = tgt_mv_t - cur_mv_t

            if abs(diff_mv) < 1e-8:
                continue

            if diff_mv < 0:
                # 卖出
                sell_mv = -diff_mv
                sell_shares = sell_mv / (open_next * (1 + cfg.slippage))
                sell_shares = min(sell_shares, cur_shares)
                proceeds = sell_shares * open_next * (1 - cfg.slippage)
                fee = proceeds * cfg.fee_rate
                cash_t1 += proceeds - fee
                shares[code] -= sell_shares
            else:
                # 买入
                buy_mv = diff_mv
                buy_shares = buy_mv / (open_next * (1 + cfg.slippage))
                cost = buy_shares * open_next * (1 + cfg.slippage)
                fee = cost * cfg.fee_rate
                total_cost = cost + fee
                if total_cost > cash_t1:
                    # 现金不够，按比例缩小买入
                    scale = cash_t1 / total_cost
                    buy_shares *= scale
                    cost = buy_shares * open_next * (1 + cfg.slippage)
                    fee = cost * cfg.fee_rate
                    total_cost = cost + fee
                cash_t1 -= total_cost
                shares[code] += buy_shares

        cash = cash_t1

        # 3) 记录 t+1 收盘时组合市值
        mv_t1 = 0.0
        for code in codes:
            dfp = price_panel[code]
            if t_next not in dfp.index:
                continue
            close_t1 = dfp.at[t_next, "close"]
            mv_t1 += shares[code] * close_t1

        equity_t1 = cash + mv_t1

        records.append(
            {
                "date": t_next,
                "equity": equity_t1,
                "cash": cash,
                "market_value": mv_t1,
            }
        )

    eq = pd.DataFrame(records).set_index("date")
    eq["ret"] = eq["equity"].pct_change().fillna(0.0)
    return eq


5. 回测引擎 v2（backtest/engine_v2.py）
# backtest/engine_v2.py
# -*- coding: utf-8 -*-
"""
BacktestEngineV2：
- 使用 v2 因子流水线（残差动量 + vol）
- 基于市场波动 regime 动态设置 buy_th / sell_th / base_target / max_positions
- 使用 soft drawdown gate 缩放 target_exposure
- 生成每日目标权重矩阵 -> 交给 execution_v2 模拟 T+1 回测
"""

from __future__ import annotations
from dataclasses import dataclass
from typing import Dict, Literal

import numpy as np
import pandas as pd

from factors.core_factors_v2 import (
    FactorWindows,
    compute_stock_factor_panel,
    build_composite_score_panel,
)
from factors.market_vol_regime import compute_index_vol_z, VolRegimeParams
from .execution_v2 import run_execution_t1_equal_weight, ExecutionConfig


RegimeType = Literal["risk_on", "neutral", "risk_off"]


@dataclass
class RegimeConfig:
    buy_th: float
    sell_th: float
    base_target: float
    max_positions: int


@dataclass
class VolConfig:
    a: float = 0.35
    k1: float = 0.08
    k2: float = 0.08


@dataclass
class DDGateConfig:
    start_dd: float = -0.05
    end_dd: float = -0.15


@dataclass
class StrategyConfigV2:
    factor_windows: FactorWindows = FactorWindows()
    regime_params: dict[RegimeType, RegimeConfig] = None
    vol_regime_params: VolRegimeParams = VolRegimeParams()
    vol_config: VolConfig = VolConfig()
    dd_gate: DDGateConfig = DDGateConfig()
    kelly_lambda: float = 0.45

    def __post_init__(self):
        if self.regime_params is None:
            self.regime_params = {
                "risk_on": RegimeConfig(0.60, 0.30, 0.95, 14),
                "neutral": RegimeConfig(0.57, 0.32, 0.65, 10),
                "risk_off": RegimeConfig(0.00, -0.20, 0.25, 6),
            }


def _soft_dd_gate(eq: pd.Series, cfg: DDGateConfig) -> pd.Series:
    peak = eq.cummax()
    dd = eq / peak - 1.0  # <=0
    g = pd.Series(index=eq.index, dtype=float)
    for dt, d in dd.items():
        if d >= cfg.start_dd:
            g[dt] = 1.0
        elif d <= cfg.end_dd:
            g[dt] = 0.0
        else:
            g[dt] = (d - cfg.end_dd) / (cfg.start_dd - cfg.end_dd)
    return g


class BacktestEngineV2:
    def __init__(
        self,
        stock_universe: Dict[str, pd.DataFrame],
        index_df: pd.DataFrame,
        strat_cfg: StrategyConfigV2 | None = None,
    ) -> None:
        """
        stock_universe: {code: df}，df 至少包含 ["open","close"]
        index_df: 指数 df，至少包含 ["close"]
        """
        self.stock_universe = stock_universe
        self.index_df = index_df
        self.cfg = strat_cfg or StrategyConfigV2()

    # ---------- 因子与打分 ----------

    def compute_scores(self) -> Dict[str, pd.DataFrame]:
        base_panel = compute_stock_factor_panel(
            self.stock_universe, self.index_df, self.cfg.factor_windows
        )
        score_panel = build_composite_score_panel(base_panel)
        return score_panel

    # ---------- regime & 阈值 ----------

    def _build_regime_series(self) -> pd.DataFrame:
        df_vol = compute_index_vol_z(self.index_df, self.cfg.vol_regime_params)
        return df_vol[["vol_z", "regime"]]

    def _get_regime_params_on_date(
        self, regime: RegimeType
    ) -> RegimeConfig:
        return self.cfg.regime_params[regime]

    # ---------- 生成 target_weights ----------

    def build_target_weights(self) -> pd.DataFrame:
        """
        返回：target_weights（index 为日期，列为 code，值为 0-1 权重）
        """
        scores = self.compute_scores()
        reg_df = self._build_regime_series()

        # 统一日期
        all_dates = sorted(
            set(reg_df.index).intersection(
                *[df.index for df in scores.values()]
            )
        )
        codes = list(self.stock_universe.keys())
        tw = pd.DataFrame(index=all_dates, columns=codes, dtype=float)

        # 初始：假设等权 Buy&Hold 的 equity，先设为 1，后面在执行器里会用真实资金
        equity_dummy = pd.Series(1.0, index=all_dates)

        dd_gate = _soft_dd_gate(equity_dummy, self.cfg.dd_gate)

        for dt in all_dates:
            if dt not in reg_df.index:
                continue
            vol_z = float(reg_df.at[dt, "vol_z"])
            regime_str: RegimeType = reg_df.at[dt, "regime"]  # type: ignore

            rp = self._get_regime_params_on_date(regime_str)

            # 波动自适应
            a = self.cfg.vol_config.a
            k1 = self.cfg.vol_config.k1
            k2 = self.cfg.vol_config.k2

            buy_th = rp.buy_th - k1 * vol_z
            sell_th = rp.sell_th + k2 * vol_z

            base_target = rp.base_target * (1.0 / (1.0 + a * vol_z))
            base_target = float(np.clip(base_target, 0.0, 1.0))

            # drawdown gate
            gate = float(dd_gate.get(dt, 1.0))
            target_exposure = base_target * gate

            # 计算截面 score
            scores_today = {}
            vol_today = {}
            for code, df in scores.items():
                if dt in df.index:
                    scores_today[code] = float(df.at[dt, "score"])
                    vol_today[code] = float(
                        df.at[dt, "vol_r"] if "vol_r" in df.columns else 0.2
                    )

            if not scores_today:
                continue

            # 截面选股：score > buy_th 的候选中取前 max_positions
            ser_score = pd.Series(scores_today)
            candidates = ser_score[ser_score > buy_th]
            if candidates.empty:
                continue

            candidates = candidates.sort_values(ascending=False)
            candidates = candidates.iloc[: rp.max_positions]

            # Kelly-lite：w_i ∝ (score - buy_th)+ / vol_i
            score_plus = candidates - buy_th
            vol_series = pd.Series({c: max(vol_today.get(c, 0.2), 1e-4)
                                    for c in candidates.index})
            raw = score_plus.clip(lower=0.0) / vol_series
            if raw.sum() <= 0:
                continue
            w = raw / raw.sum()

            w = w * (target_exposure * self.cfg.kelly_lambda)

            for code in candidates.index:
                tw.at[dt, code] = w[code]

        tw = tw.fillna(0.0)
        return tw

    # ---------- 主回测入口 ----------

    def run_backtest(
        self,
        exec_cfg: ExecutionConfig | None = None,
    ) -> pd.DataFrame:
        target_weights = self.build_target_weights()
        eq = run_execution_t1_equal_weight(
            price_panel=self.stock_universe,
            target_weights=target_weights,
            cfg=exec_cfg,
        )
        return eq


这套代码是一个“骨架版”的 v2 引擎，核心逻辑都已经搭好：


残差动量 + 横截面排名 → score


市场波动 z-score → regime + 动态 buy/sell 阈值 + 动态 base_target


soft MDD gate + Kelly-lite → target_exposure


TopN + 权重分配 → target_weights


T+1 执行 → 资金曲线


你可以先：


在项目里新建这些文件；


用你现有的股票池加载成 stock_universe: Dict[str, DataFrame] 和一个 HS300 指数 df；


在一个小脚本里调用：


from backtest.engine_v2 import BacktestEngineV2, StrategyConfigV2
from backtest.execution_v2 import ExecutionConfig

engine = BacktestEngineV2(stock_universe, index_df, StrategyConfigV2())
equity = engine.run_backtest(ExecutionConfig(initial_cash=1_000_000))

print(equity.tail())

如果你愿意，我可以下一步直接给你一个 run_backtest_v2.py，读你现有的 CSV（用 gm_loader 或 universe_loader），把这一整套串起来。
